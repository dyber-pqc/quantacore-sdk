//! Key Encapsulation Mechanism (KEM) operations.
//!
//! This module provides post-quantum key encapsulation using ML-KEM (Kyber).

use crate::device::Device;
use crate::error::{check_error, Result};
use crate::ffi;
use crate::types::KemAlgorithm;

use zeroize::ZeroizeOnDrop;

/// KEM key pair.
///
/// Contains the public and secret keys generated by KEM key generation.
/// The secret key is automatically zeroed when dropped.
#[derive(Clone, ZeroizeOnDrop)]
pub struct KeyPair {
    /// Public key bytes
    #[zeroize(skip)]
    public_key: Vec<u8>,
    /// Secret key bytes (zeroized on drop)
    secret_key: Vec<u8>,
    /// Algorithm used
    #[zeroize(skip)]
    algorithm: KemAlgorithm,
}

impl KeyPair {
    /// Create a new key pair.
    fn new(public_key: Vec<u8>, secret_key: Vec<u8>, algorithm: KemAlgorithm) -> Self {
        Self {
            public_key,
            secret_key,
            algorithm,
        }
    }

    /// Get the public key.
    pub fn public_key(&self) -> &[u8] {
        &self.public_key
    }

    /// Get the secret key.
    pub fn secret_key(&self) -> &[u8] {
        &self.secret_key
    }

    /// Get the algorithm.
    pub fn algorithm(&self) -> KemAlgorithm {
        self.algorithm
    }

    /// Consume the key pair and return the raw bytes.
    ///
    /// The caller is responsible for zeroing the secret key.
    pub fn into_bytes(mut self) -> (Vec<u8>, Vec<u8>) {
        let pk = std::mem::take(&mut self.public_key);
        let sk = std::mem::take(&mut self.secret_key);
        std::mem::forget(self); // Don't run destructor
        (pk, sk)
    }
}

impl std::fmt::Debug for KeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("KeyPair")
            .field("algorithm", &self.algorithm)
            .field("public_key_len", &self.public_key.len())
            .field("secret_key_len", &self.secret_key.len())
            .finish()
    }
}

/// Result of KEM encapsulation.
///
/// Contains the ciphertext and shared secret. The shared secret
/// is automatically zeroed when dropped.
#[derive(Clone, ZeroizeOnDrop)]
pub struct EncapsulationResult {
    /// Ciphertext bytes
    #[zeroize(skip)]
    ciphertext: Vec<u8>,
    /// Shared secret bytes (zeroized on drop)
    shared_secret: Vec<u8>,
}

impl EncapsulationResult {
    /// Create a new encapsulation result.
    fn new(ciphertext: Vec<u8>, shared_secret: Vec<u8>) -> Self {
        Self {
            ciphertext,
            shared_secret,
        }
    }

    /// Get the ciphertext.
    pub fn ciphertext(&self) -> &[u8] {
        &self.ciphertext
    }

    /// Get the shared secret.
    pub fn shared_secret(&self) -> &[u8] {
        &self.shared_secret
    }

    /// Consume and return as tuple.
    pub fn into_parts(mut self) -> (Vec<u8>, Vec<u8>) {
        let ct = std::mem::take(&mut self.ciphertext);
        let ss = std::mem::take(&mut self.shared_secret);
        std::mem::forget(self);
        (ct, ss)
    }
}

impl std::fmt::Debug for EncapsulationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EncapsulationResult")
            .field("ciphertext_len", &self.ciphertext.len())
            .field("shared_secret_len", &self.shared_secret.len())
            .finish()
    }
}

/// KEM (Key Encapsulation Mechanism) subsystem.
///
/// Provides access to post-quantum key encapsulation operations
/// using ML-KEM (formerly Kyber).
///
/// # Example
///
/// ```no_run
/// use quantacore::{initialize, open_first_device, KemAlgorithm};
///
/// initialize().unwrap();
/// let device = open_first_device().unwrap();
/// let kem = device.kem();
///
/// // Generate key pair
/// let keypair = kem.generate_keypair(KemAlgorithm::MlKem768).unwrap();
///
/// // Encapsulate (sender side)
/// let (ciphertext, sender_secret) = kem.encapsulate(
///     keypair.public_key(),
///     KemAlgorithm::MlKem768
/// ).unwrap();
///
/// // Decapsulate (receiver side)
/// let receiver_secret = kem.decapsulate(
///     keypair.secret_key(),
///     &ciphertext,
///     KemAlgorithm::MlKem768
/// ).unwrap();
///
/// assert_eq!(sender_secret, receiver_secret);
/// ```
#[derive(Clone)]
pub struct Kem {
    device: Device,
}

impl Kem {
    /// Create a new KEM subsystem handle.
    pub(crate) fn new(device: Device) -> Self {
        Self { device }
    }

    /// Generate a KEM key pair.
    ///
    /// # Arguments
    ///
    /// * `algorithm` - The KEM algorithm to use
    ///
    /// # Returns
    ///
    /// A `KeyPair` containing the public and secret keys.
    pub fn generate_keypair(&self, algorithm: KemAlgorithm) -> Result<KeyPair> {
        let pk_size = algorithm.public_key_size();
        let sk_size = algorithm.secret_key_size();

        let mut public_key = vec![0u8; pk_size];
        let mut secret_key = vec![0u8; sk_size];
        let mut pk_len = pk_size;
        let mut sk_len = sk_size;

        let result = unsafe {
            ffi::quac_kem_keygen(
                self.device.handle(),
                algorithm.to_raw(),
                public_key.as_mut_ptr(),
                &mut pk_len,
                secret_key.as_mut_ptr(),
                &mut sk_len,
            )
        };

        check_error(result)?;

        public_key.truncate(pk_len);
        secret_key.truncate(sk_len);

        Ok(KeyPair::new(public_key, secret_key, algorithm))
    }

    /// Generate ML-KEM-512 key pair.
    pub fn generate_keypair_512(&self) -> Result<KeyPair> {
        self.generate_keypair(KemAlgorithm::MlKem512)
    }

    /// Generate ML-KEM-768 key pair.
    pub fn generate_keypair_768(&self) -> Result<KeyPair> {
        self.generate_keypair(KemAlgorithm::MlKem768)
    }

    /// Generate ML-KEM-1024 key pair.
    pub fn generate_keypair_1024(&self) -> Result<KeyPair> {
        self.generate_keypair(KemAlgorithm::MlKem1024)
    }

    /// Encapsulate to generate a shared secret and ciphertext.
    ///
    /// This is the sender's operation. The ciphertext should be sent
    /// to the recipient who can decapsulate using their secret key.
    ///
    /// # Arguments
    ///
    /// * `public_key` - The recipient's public key
    /// * `algorithm` - The KEM algorithm to use
    ///
    /// # Returns
    ///
    /// A tuple of (ciphertext, shared_secret).
    pub fn encapsulate(
        &self,
        public_key: &[u8],
        algorithm: KemAlgorithm,
    ) -> Result<(Vec<u8>, Vec<u8>)> {
        let ct_size = algorithm.ciphertext_size();
        let ss_size = algorithm.shared_secret_size();

        let mut ciphertext = vec![0u8; ct_size];
        let mut shared_secret = vec![0u8; ss_size];
        let mut ct_len = ct_size;
        let mut ss_len = ss_size;

        let result = unsafe {
            ffi::quac_kem_encapsulate(
                self.device.handle(),
                algorithm.to_raw(),
                public_key.as_ptr(),
                public_key.len(),
                ciphertext.as_mut_ptr(),
                &mut ct_len,
                shared_secret.as_mut_ptr(),
                &mut ss_len,
            )
        };

        check_error(result)?;

        ciphertext.truncate(ct_len);
        shared_secret.truncate(ss_len);

        Ok((ciphertext, shared_secret))
    }

    /// Encapsulate returning an `EncapsulationResult`.
    pub fn encapsulate_result(
        &self,
        public_key: &[u8],
        algorithm: KemAlgorithm,
    ) -> Result<EncapsulationResult> {
        let (ct, ss) = self.encapsulate(public_key, algorithm)?;
        Ok(EncapsulationResult::new(ct, ss))
    }

    /// Encapsulate using ML-KEM-512.
    pub fn encapsulate_512(&self, public_key: &[u8]) -> Result<(Vec<u8>, Vec<u8>)> {
        self.encapsulate(public_key, KemAlgorithm::MlKem512)
    }

    /// Encapsulate using ML-KEM-768.
    pub fn encapsulate_768(&self, public_key: &[u8]) -> Result<(Vec<u8>, Vec<u8>)> {
        self.encapsulate(public_key, KemAlgorithm::MlKem768)
    }

    /// Encapsulate using ML-KEM-1024.
    pub fn encapsulate_1024(&self, public_key: &[u8]) -> Result<(Vec<u8>, Vec<u8>)> {
        self.encapsulate(public_key, KemAlgorithm::MlKem1024)
    }

    /// Decapsulate to recover the shared secret.
    ///
    /// This is the recipient's operation. Use the secret key and
    /// received ciphertext to recover the shared secret.
    ///
    /// # Arguments
    ///
    /// * `secret_key` - The recipient's secret key
    /// * `ciphertext` - The ciphertext received from the sender
    /// * `algorithm` - The KEM algorithm to use
    ///
    /// # Returns
    ///
    /// The shared secret (same as the sender's).
    pub fn decapsulate(
        &self,
        secret_key: &[u8],
        ciphertext: &[u8],
        algorithm: KemAlgorithm,
    ) -> Result<Vec<u8>> {
        let ss_size = algorithm.shared_secret_size();
        let mut shared_secret = vec![0u8; ss_size];
        let mut ss_len = ss_size;

        let result = unsafe {
            ffi::quac_kem_decapsulate(
                self.device.handle(),
                algorithm.to_raw(),
                secret_key.as_ptr(),
                secret_key.len(),
                ciphertext.as_ptr(),
                ciphertext.len(),
                shared_secret.as_mut_ptr(),
                &mut ss_len,
            )
        };

        check_error(result)?;
        shared_secret.truncate(ss_len);

        Ok(shared_secret)
    }

    /// Decapsulate using ML-KEM-512.
    pub fn decapsulate_512(&self, secret_key: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>> {
        self.decapsulate(secret_key, ciphertext, KemAlgorithm::MlKem512)
    }

    /// Decapsulate using ML-KEM-768.
    pub fn decapsulate_768(&self, secret_key: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>> {
        self.decapsulate(secret_key, ciphertext, KemAlgorithm::MlKem768)
    }

    /// Decapsulate using ML-KEM-1024.
    pub fn decapsulate_1024(&self, secret_key: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>> {
        self.decapsulate(secret_key, ciphertext, KemAlgorithm::MlKem1024)
    }
}

impl std::fmt::Debug for Kem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Kem").finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_keypair_debug_hides_secret() {
        let kp = KeyPair::new(
            vec![1, 2, 3],
            vec![4, 5, 6],
            KemAlgorithm::MlKem768,
        );
        let debug = format!("{:?}", kp);
        assert!(!debug.contains("[4, 5, 6]"));
        assert!(debug.contains("secret_key_len"));
    }

    #[test]
    fn test_encapsulation_result_debug() {
        let result = EncapsulationResult::new(vec![1, 2, 3], vec![4, 5, 6]);
        let debug = format!("{:?}", result);
        assert!(debug.contains("ciphertext_len"));
    }
}
